<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>Mosaic Generator</title>
    <style>
        body {
          font-family: sans-serif;
          text-align: center;
          margin: 2rem;
        }

        canvas {
          border: 2px solid #333;
          margin-top: 1rem;
          cursor: pointer;
        }

        #tooltip {
          position: absolute;
          padding: 8px;
          background: rgba(0, 0, 0, 0.85);
          color: white;
          border-radius: 4px;
          font-size: 13px;
          pointer-events: none;
          display: none;
          z-index: 10;
          max-width: 250px;
          white-space: nowrap;
        }

        #loader {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 18px;
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 12px 24px;
          border-radius: 8px;
          display: none;
          z-index: 999;
        }
    </style>
</head>
<body>
<h1>Mosaic Generator</h1>
<input type="file" id="input_image" accept="image/*"/>
<br><br>
<label for="mosaic_size">Mosaic Size (e.g. 8 for 8√ó8):</label>
<input type="number" id="mosaic_size" value="8" min="4" max="128"/>
<button id="submit">Generate Mosaic</button>
<br/>
<canvas id="mosaic" width="512" height="512"></canvas>
<div id="tooltip"></div>
<div id="loader">ü™ê Generating mosaic... Please wait</div>

<script>
    const tooltip = document.getElementById("tooltip");
    const loader = document.getElementById("loader");
    const canvas = document.getElementById("mosaic");
    const ctx = canvas.getContext("2d");

    let tileMetadata = [];
    let gridSize = 8;
    let tileSize = 64;

    async function drawMosaic(tileData, gridSizeInput) {
      gridSize = gridSizeInput;
      tileSize = Math.floor(canvas.width / gridSize);
      tileMetadata = tileData;

      for (let i = 0; i < tileData.length; i++) {
        const tile = tileData[i];
        const row = Math.floor(i / gridSize);
        const col = i % gridSize;
        const x = col * tileSize;
        const y = row * tileSize;

        try {
          const img = await loadImage(tile.image_url);
          ctx.drawImage(img, x, y, tileSize, tileSize);
        } catch (err) {
          const c = tile.average_color;
          ctx.fillStyle = `rgb(${c.r}, ${c.g}, ${c.b})`;
          ctx.fillRect(x, y, tileSize, tileSize);
        }
      }
    }

    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    async function generateAndDrawMosaic() {
      const fileInput = document.getElementById("input_image");
      const file = fileInput.files[0];
      const sizeInput = parseInt(document.getElementById("mosaic_size").value, 10);
      if (!file || isNaN(sizeInput)) {
        alert("Please select an image and enter a valid mosaic size.");
        return;
      }

      const formData = new FormData();
      formData.append("image", file);
      formData.append("mosaic_size", sizeInput);

      loader.style.display = "block";

      try {
        const res = await fetch("/mosaic_generator", {
          method: "POST",
          body: formData
        });

        if (!res.ok) {
          const err = await res.json();
          throw new Error(err.detail || "Unknown error");
        }

        const data = await res.json();
        await drawMosaic(data.mosaic_tiles, sizeInput);
      } catch (e) {
        alert("Failed to generate mosaic: " + e.message);
      } finally {
        loader.style.display = "none";
      }
    }

    document.getElementById("submit").addEventListener("click", generateAndDrawMosaic);

    // Tooltip behavior
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const col = Math.floor(x / tileSize);
      const row = Math.floor(y / tileSize);
      const index = row * gridSize + col;

      if (tileMetadata[index]) {
        const tile = tileMetadata[index];
        tooltip.style.left = `${e.pageX + 10}px`;
        tooltip.style.top = `${e.pageY + 10}px`;
        tooltip.style.display = "block";
        tooltip.innerHTML = `
          <strong>Source:</strong> ${tile.source}<br>
          <strong>Date:</strong> ${tile.date}<br>
          <strong>Classification:</strong> ${tile.classification}<br>
          <strong>R,G,B:</strong> ${tile.average_color.r}, ${tile.average_color.g}, ${tile.average_color.b}
        `;
      } else {
        tooltip.style.display = "none";
      }
    });

    canvas.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
    });

    // Open image on click
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const col = Math.floor(x / tileSize);
      const row = Math.floor(y / tileSize);
      const index = row * gridSize + col;

      if (tileMetadata[index]?.image_url) {
        window.open(tileMetadata[index].image_url, "_blank");
      }
    });
</script>
</body>
</html>
